<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpeg: libavutil/parseutils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpeg
   &#160;<span id="projectnumber">4.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_8d855866ba5d436d839c7fc557836cd9.html">libavutil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">parseutils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>misc parsing utilities  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="time_8h_source.html">time.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rational_8h_source.html">rational.h</a>&quot;</code><br />
</div>
<p><a href="parseutils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8ac8244d56fd4eeb9557038f80d60560"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#a8ac8244d56fd4eeb9557038f80d60560">av_parse_ratio_quiet</a>(rate,  str,  max)&#160;&#160;&#160;<a class="el" href="parseutils_8h.html#a8535b8693aa5a188cfb1356133c0e94e">av_parse_ratio</a>(rate, str, max, <a class="el" href="group__lavu__log__constants.html#gad87b54332d00f280bf5db0fd2f56f340">AV_LOG_MAX_OFFSET</a>, NULL)</td></tr>
<tr class="separator:a8ac8244d56fd4eeb9557038f80d60560"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8535b8693aa5a188cfb1356133c0e94e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#a8535b8693aa5a188cfb1356133c0e94e">av_parse_ratio</a> (<a class="el" href="structAVRational.html">AVRational</a> *q, const char *str, int max, int log_offset, void *log_ctx)</td></tr>
<tr class="memdesc:a8535b8693aa5a188cfb1356133c0e94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse str and store the parsed ratio in q.  <a href="#a8535b8693aa5a188cfb1356133c0e94e">More...</a><br /></td></tr>
<tr class="separator:a8535b8693aa5a188cfb1356133c0e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcdb8a2792f2074ca4a1e1f4ddce2bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#a4dcdb8a2792f2074ca4a1e1f4ddce2bf">av_parse_video_size</a> (int *width_ptr, int *height_ptr, const char *str)</td></tr>
<tr class="memdesc:a4dcdb8a2792f2074ca4a1e1f4ddce2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse str and put in width_ptr and height_ptr the detected values.  <a href="#a4dcdb8a2792f2074ca4a1e1f4ddce2bf">More...</a><br /></td></tr>
<tr class="separator:a4dcdb8a2792f2074ca4a1e1f4ddce2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc4de8c071538f5bbde8e5b7466b676"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#abbc4de8c071538f5bbde8e5b7466b676">av_parse_video_rate</a> (<a class="el" href="structAVRational.html">AVRational</a> *rate, const char *str)</td></tr>
<tr class="memdesc:abbc4de8c071538f5bbde8e5b7466b676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse str and store the detected values in *rate.  <a href="#abbc4de8c071538f5bbde8e5b7466b676">More...</a><br /></td></tr>
<tr class="separator:abbc4de8c071538f5bbde8e5b7466b676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be8779c7c2afd9c57c8b962bea76d03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#a4be8779c7c2afd9c57c8b962bea76d03">av_parse_color</a> (uint8_t *rgba_color, const char *color_string, int slen, void *log_ctx)</td></tr>
<tr class="memdesc:a4be8779c7c2afd9c57c8b962bea76d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put the RGBA values that correspond to color_string in rgba_color.  <a href="#a4be8779c7c2afd9c57c8b962bea76d03">More...</a><br /></td></tr>
<tr class="separator:a4be8779c7c2afd9c57c8b962bea76d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138ca9f3643dfffbf9737b1f44ad27e3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#a138ca9f3643dfffbf9737b1f44ad27e3">av_get_known_color_name</a> (int color_idx, const uint8_t **rgb)</td></tr>
<tr class="memdesc:a138ca9f3643dfffbf9737b1f44ad27e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a color from the internal table of hard-coded named colors.  <a href="#a138ca9f3643dfffbf9737b1f44ad27e3">More...</a><br /></td></tr>
<tr class="separator:a138ca9f3643dfffbf9737b1f44ad27e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98590feafe82e074f61f38c8faaa4cef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#a98590feafe82e074f61f38c8faaa4cef">av_parse_time</a> (int64_t *timeval, const char *timestr, int duration)</td></tr>
<tr class="memdesc:a98590feafe82e074f61f38c8faaa4cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse timestr and return in *time a corresponding number of microseconds.  <a href="#a98590feafe82e074f61f38c8faaa4cef">More...</a><br /></td></tr>
<tr class="separator:a98590feafe82e074f61f38c8faaa4cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97f06e907c14c253c2bf3e775f51ccb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#ad97f06e907c14c253c2bf3e775f51ccb">av_find_info_tag</a> (char *arg, int arg_size, const char *tag1, const char *info)</td></tr>
<tr class="memdesc:ad97f06e907c14c253c2bf3e775f51ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to find a specific tag in a URL.  <a href="#ad97f06e907c14c253c2bf3e775f51ccb">More...</a><br /></td></tr>
<tr class="separator:ad97f06e907c14c253c2bf3e775f51ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5cd7c7ffea52ca3697864253384ffe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#acd5cd7c7ffea52ca3697864253384ffe">av_small_strptime</a> (const char *p, const char *fmt, struct tm *dt)</td></tr>
<tr class="memdesc:acd5cd7c7ffea52ca3697864253384ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplified version of strptime.  <a href="#acd5cd7c7ffea52ca3697864253384ffe">More...</a><br /></td></tr>
<tr class="separator:acd5cd7c7ffea52ca3697864253384ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bf34b50b9762f3c733721d5210b52d"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parseutils_8h.html#ae9bf34b50b9762f3c733721d5210b52d">av_timegm</a> (struct tm *tm)</td></tr>
<tr class="memdesc:ae9bf34b50b9762f3c733721d5210b52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the decomposed UTC time in tm to a time_t value.  <a href="#ae9bf34b50b9762f3c733721d5210b52d">More...</a><br /></td></tr>
<tr class="separator:ae9bf34b50b9762f3c733721d5210b52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>misc parsing utilities </p>

<p class="definition">Definition in file <a class="el" href="parseutils_8h_source.html">parseutils.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8ac8244d56fd4eeb9557038f80d60560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac8244d56fd4eeb9557038f80d60560">&#9670;&nbsp;</a></span>av_parse_ratio_quiet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define av_parse_ratio_quiet</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="parseutils_8h.html#a8535b8693aa5a188cfb1356133c0e94e">av_parse_ratio</a>(rate, str, max, <a class="el" href="group__lavu__log__constants.html#gad87b54332d00f280bf5db0fd2f56f340">AV_LOG_MAX_OFFSET</a>, NULL)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parseutils_8h_source.html#l00052">52</a> of file <a class="el" href="parseutils_8h_source.html">parseutils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8535b8693aa5a188cfb1356133c0e94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8535b8693aa5a188cfb1356133c0e94e">&#9670;&nbsp;</a></span>av_parse_ratio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_parse_ratio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVRational.html">AVRational</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>log_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>log_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse str and store the parsed ratio in q. </p>
<p>Note that a ratio with infinite (1/0) or negative value is considered valid, so you should check on the returned value if you want to exclude those values.</p>
<p>The undefined value can be expressed using the "0:0" string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">q</td><td>pointer to the <a class="el" href="structAVRational.html" title="Rational number (pair of numerator and denominator). ">AVRational</a> which will contain the ratio </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>the string to parse: it has to be a string in the format num:den, a float number or an expression </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>the maximum allowed numerator and denominator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_offset</td><td>log level offset which is applied to the log level of log_ctx </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_ctx</td><td>parent logging context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, a negative error code otherwise </dd></dl>

</div>
</div>
<a id="a4dcdb8a2792f2074ca4a1e1f4ddce2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcdb8a2792f2074ca4a1e1f4ddce2bf">&#9670;&nbsp;</a></span>av_parse_video_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_parse_video_size </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse str and put in width_ptr and height_ptr the detected values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">width_ptr</td><td>pointer to the variable which will contain the detected width value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">height_ptr</td><td>pointer to the variable which will contain the detected height value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>the string to parse: it has to be a string in the format width x height or a valid video size abbreviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, a negative error code otherwise </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="scaling_video_8c-example.html#a6">scaling_video.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="scaling__video_8c_source.html#l00052">main()</a>.</p>

</div>
</div>
<a id="abbc4de8c071538f5bbde8e5b7466b676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc4de8c071538f5bbde8e5b7466b676">&#9670;&nbsp;</a></span>av_parse_video_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_parse_video_rate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVRational.html">AVRational</a> *&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse str and store the detected values in *rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rate</td><td>pointer to the <a class="el" href="structAVRational.html" title="Rational number (pair of numerator and denominator). ">AVRational</a> which will contain the detected frame rate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>the string to parse: it has to be a string in the format rate_num / rate_den, a float number or a valid video rate abbreviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, a negative error code otherwise </dd></dl>

</div>
</div>
<a id="a4be8779c7c2afd9c57c8b962bea76d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be8779c7c2afd9c57c8b962bea76d03">&#9670;&nbsp;</a></span>av_parse_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_parse_color </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rgba_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>color_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>log_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put the RGBA values that correspond to color_string in rgba_color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color_string</td><td>a string specifying a color. It can be the name of a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence, possibly followed by "@" and a string representing the alpha component. The alpha component may be a string composed by "0x" followed by an hexadecimal number or a decimal number between 0.0 and 1.0, which represents the opacity value (0x00/0.0 means completely transparent, 0xff/1.0 completely opaque). If the alpha component is not specified then 0xff is assumed. The string "random" will result in a random color. </td></tr>
    <tr><td class="paramname">slen</td><td>length of the initial part of color_string containing the color. It can be set to -1 if color_string is a null terminated string containing nothing else than the color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 in case of success, a negative value in case of failure (for example if color_string cannot be parsed). </dd></dl>

</div>
</div>
<a id="a138ca9f3643dfffbf9737b1f44ad27e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138ca9f3643dfffbf9737b1f44ad27e3">&#9670;&nbsp;</a></span>av_get_known_color_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_get_known_color_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a color from the internal table of hard-coded named colors. </p>
<p>This function is meant to enumerate the color names recognized by <a class="el" href="parseutils_8h.html#a4be8779c7c2afd9c57c8b962bea76d03" title="Put the RGBA values that correspond to color_string in rgba_color. ">av_parse_color()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color_idx</td><td>index of the requested color, starting from 0 </td></tr>
    <tr><td class="paramname">rgbp</td><td>if not NULL, will point to a 3-elements array with the color value in RGB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the color name string or NULL if color_idx is not in the array </dd></dl>

</div>
</div>
<a id="a98590feafe82e074f61f38c8faaa4cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98590feafe82e074f61f38c8faaa4cef">&#9670;&nbsp;</a></span>av_parse_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_parse_time </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>timeval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>timestr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse timestr and return in *time a corresponding number of microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeval</td><td>puts here the number of microseconds corresponding to the string in timestr. If the string represents a duration, it is the number of microseconds contained in the time interval. If the string is a date, is the number of microseconds since 1st of January, 1970 up to the time of the parsed date. If timestr cannot be successfully parsed, set *time to INT64_MIN.</td></tr>
    <tr><td class="paramname">timestr</td><td>a string representing a date or a duration.<ul>
<li>If a date the syntax is: <div class="fragment"><div class="line">[{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]</div><div class="line">now</div></div><!-- fragment --> If the value is "now" it takes the current time. Time is local time unless Z is appended, in which case it is interpreted as UTC. If the year-month-day part is not specified it takes the current year-month-day.</li>
<li>If a duration the syntax is: <div class="fragment"><div class="line">[-][HH:]MM:SS[.m...]</div><div class="line">[-]S+[.m...]</div></div><!-- fragment --> </li>
</ul>
</td></tr>
    <tr><td class="paramname">duration</td><td>flag which tells how to interpret timestr, if not zero timestr is interpreted as a duration, otherwise as a date </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 in case of success, a negative value corresponding to an AVERROR code otherwise </dd></dl>

</div>
</div>
<a id="ad97f06e907c14c253c2bf3e775f51ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97f06e907c14c253c2bf3e775f51ccb">&#9670;&nbsp;</a></span>av_find_info_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_find_info_tag </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tag1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to find a specific tag in a URL. </p>
<p>syntax: '?tag1=val1&amp;tag2=val2...'. Little URL decoding is done. Return 1 if found. </p>

</div>
</div>
<a id="acd5cd7c7ffea52ca3697864253384ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5cd7c7ffea52ca3697864253384ffe">&#9670;&nbsp;</a></span>av_small_strptime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* av_small_strptime </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplified version of strptime. </p>
<p>Parse the input string p according to the format string fmt and store its results in the structure dt. This implementation supports only a subset of the formats supported by the standard strptime().</p>
<p>The supported input field descriptors are listed below.</p><ul>
<li>H: the hour as a decimal number, using a 24-hour clock, in the range '00' through '23'</li>
<li>J: hours as a decimal number, in the range '0' through INT_MAX</li>
<li>M: the minute as a decimal number, using a 24-hour clock, in the range '00' through '59'</li>
<li>S: the second as a decimal number, using a 24-hour clock, in the range '00' through '59'</li>
<li>Y: the year as a decimal number, using the Gregorian calendar</li>
<li>m: the month as a decimal number, in the range '1' through '12'</li>
<li>d: the day of the month as a decimal number, in the range '1' through '31'</li>
<li>T: alias for 'H:M:S'</li>
<li>%%: a literal ''</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first character not processed in this function call. In case the input string contains more characters than required by the format string the return value points right after the last consumed input character. In case the whole input string is consumed the return value points to the null byte at the end of the string. On failure NULL is returned. </dd></dl>

</div>
</div>
<a id="ae9bf34b50b9762f3c733721d5210b52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bf34b50b9762f3c733721d5210b52d">&#9670;&nbsp;</a></span>av_timegm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t av_timegm </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>tm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the decomposed UTC time in tm to a time_t value. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
