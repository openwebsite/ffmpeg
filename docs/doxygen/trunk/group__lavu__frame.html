<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpeg: AVFrame</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpeg
   &#160;<span id="projectnumber">4.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AVFrame<div class="ingroups"><a class="el" href="group__lavu.html">libavutil</a> &raquo; <a class="el" href="group__lavu__data.html">Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> is an abstraction for reference-counted raw multimedia data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__lavu__frame__flags"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame__flags.html">AV_FRAME_FLAGS</a></td></tr>
<tr class="memdesc:group__lavu__frame__flags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags describing additional frame properties. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:frame_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="frame_8h.html">frame.h</a></td></tr>
<tr class="memdesc:frame_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference-counted frame API <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAVFrameSideData.html">AVFrameSideData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold side data for an <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a>.  <a href="structAVFrameSideData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAVRegionOfInterest.html">AVRegionOfInterest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure describing a single Region Of Interest.  <a href="structAVRegionOfInterest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAVFrame.html">AVFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure describes decoded (raw) audio or video data.  <a href="structAVFrame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae01fa7e427274293aacdf2adc17076bc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> { <br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca3de91a03b453c956b7274a2392d9a437">AV_FRAME_DATA_PANSCAN</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca4848fd3952b4c2e1c1b85acb628c78a6">AV_FRAME_DATA_A53_CC</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bcacec681d6146e8bd4c61b2e1cc88354a8">AV_FRAME_DATA_STEREO3D</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bcaa69ea5c11a5431bfff9e565714dafe41">AV_FRAME_DATA_MATRIXENCODING</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca71819257ea0bedb7e0740a0ce60e404a">AV_FRAME_DATA_DOWNMIX_INFO</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca66f46a9df9fcb8cf212e0693465794e1">AV_FRAME_DATA_REPLAYGAIN</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca3e01b882b6fa04724076067d6d9f8b69">AV_FRAME_DATA_DISPLAYMATRIX</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca9aabf5c0b8abc7064bfcc59485e54aea">AV_FRAME_DATA_AFD</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bcaf50d0ed0a9a4517341c221be03a06c42">AV_FRAME_DATA_MOTION_VECTORS</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca6b0b1ee4315f322922710f65d02a146b">AV_FRAME_DATA_SKIP_SAMPLES</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca51023c847159dcc08776f9dcee5e0c90">AV_FRAME_DATA_AUDIO_SERVICE_TYPE</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca6e305f92e325fbd219527452048f16cb">AV_FRAME_DATA_MASTERING_DISPLAY_METADATA</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca03982b828a1069c895d16cda4b3e9fd4">AV_FRAME_DATA_GOP_TIMECODE</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca12806c5fd4b37dca88312c61965f33e8">AV_FRAME_DATA_SPHERICAL</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca311f0afd2dded92ef68ae00f7711aa2d">AV_FRAME_DATA_CONTENT_LIGHT_LEVEL</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca8ef8866b8c04c54c630479bc163196ae">AV_FRAME_DATA_ICC_PROFILE</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca716dc238a2bea3693a52ab658c4e8ff7">AV_FRAME_DATA_QP_TABLE_PROPERTIES</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca880fdfc059a05584749d695cc54e4717">AV_FRAME_DATA_QP_TABLE_DATA</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca9f4e4ed5a874d1089ec07c384b81bb70">AV_FRAME_DATA_S12M_TIMECODE</a>, 
<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bca624c3831cce31e4fcd3d2dc77c10b226">AV_FRAME_DATA_DYNAMIC_HDR_PLUS</a>, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#ggae01fa7e427274293aacdf2adc17076bcaf525ec92d2c5a78d44950bc3f29972aa">AV_FRAME_DATA_REGIONS_OF_INTEREST</a>
<br />
 }</td></tr>
<tr class="separator:gae01fa7e427274293aacdf2adc17076bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612627d8f03d52317992979dfa151d76"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga612627d8f03d52317992979dfa151d76">AVActiveFormatDescription</a> { <br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76a0e9a49946d70eb6ca77cf937ed1a342c">AV_AFD_SAME</a> = 8, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76ab118e63239595dceb50deea7351dc1cb">AV_AFD_4_3</a> = 9, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76ad8f8850e69a05765363a4a833adc97d8">AV_AFD_16_9</a> = 10, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76a0da920de1ba63c73fabe1b9878477a13">AV_AFD_14_9</a> = 11, 
<br />
&#160;&#160;<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76a65edb00603a0d7fdb37cecac94b62cc5">AV_AFD_4_3_SP_14_9</a> = 13, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76a488ce7ad4833c96497000dd03b8f0b55">AV_AFD_16_9_SP_14_9</a> = 14, 
<a class="el" href="group__lavu__frame.html#gga612627d8f03d52317992979dfa151d76aac53fd979d24b22c0673d1a0bc59e304">AV_AFD_SP_4_3</a> = 15
<br />
 }</td></tr>
<tr class="separator:ga612627d8f03d52317992979dfa151d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61dadd085c1777f559549e05962b2c9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__lavu__frame.html#gga61dadd085c1777f559549e05962b2c9ea8df6ec39909b8d97c0a6d2d8465d2e0f">AV_FRAME_CROP_UNALIGNED</a> = 1 &lt;&lt; 0
 }<tr class="memdesc:ga61dadd085c1777f559549e05962b2c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for frame cropping.  <a href="group__lavu__frame.html#ga61dadd085c1777f559549e05962b2c9e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga61dadd085c1777f559549e05962b2c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga925e7d083e99a910b9c21268636cb712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga925e7d083e99a910b9c21268636cb712">av_frame_get_best_effort_timestamp</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="memdesc:ga925e7d083e99a910b9c21268636cb712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessors for some <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> fields.  <a href="#ga925e7d083e99a910b9c21268636cb712">More...</a><br /></td></tr>
<tr class="separator:ga925e7d083e99a910b9c21268636cb712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7708227eba08ff739576c251b174934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gad7708227eba08ff739576c251b174934">av_frame_set_best_effort_timestamp</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int64_t val)</td></tr>
<tr class="separator:gad7708227eba08ff739576c251b174934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50494987e9226a176284ae7f6134efc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga50494987e9226a176284ae7f6134efc0">av_frame_get_pkt_duration</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:ga50494987e9226a176284ae7f6134efc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b0960f75af92d98a41b5d640d31af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga58b0960f75af92d98a41b5d640d31af5">av_frame_set_pkt_duration</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int64_t val)</td></tr>
<tr class="separator:ga58b0960f75af92d98a41b5d640d31af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65d2eb53158d00661efbdacdb1eef103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga65d2eb53158d00661efbdacdb1eef103">av_frame_get_pkt_pos</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:ga65d2eb53158d00661efbdacdb1eef103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ebf63faa7bd8855738f8c6825d6da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gae2ebf63faa7bd8855738f8c6825d6da6">av_frame_set_pkt_pos</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int64_t val)</td></tr>
<tr class="separator:gae2ebf63faa7bd8855738f8c6825d6da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b71b6339d48f71999688af70190beee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga8b71b6339d48f71999688af70190beee">av_frame_get_channel_layout</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:ga8b71b6339d48f71999688af70190beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87a6e7cdf7fe675be91b655dc4ae794e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga87a6e7cdf7fe675be91b655dc4ae794e">av_frame_set_channel_layout</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int64_t val)</td></tr>
<tr class="separator:ga87a6e7cdf7fe675be91b655dc4ae794e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga590db2f240eaa6ce998bfe3df5b9cb22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga590db2f240eaa6ce998bfe3df5b9cb22">av_frame_get_channels</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:ga590db2f240eaa6ce998bfe3df5b9cb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f781c6fc731399b2cdf63a97978d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga53f781c6fc731399b2cdf63a97978d35">av_frame_set_channels</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int val)</td></tr>
<tr class="separator:ga53f781c6fc731399b2cdf63a97978d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadbff484111a2603b15cf982a4e710c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaadbff484111a2603b15cf982a4e710c8">av_frame_get_sample_rate</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:gaadbff484111a2603b15cf982a4e710c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b97de1236751c84523961595233837b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga7b97de1236751c84523961595233837b">av_frame_set_sample_rate</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int val)</td></tr>
<tr class="separator:ga7b97de1236751c84523961595233837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c98b281c71db3fe71d9934d775fcc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaa0c98b281c71db3fe71d9934d775fcc0">av_frame_get_metadata</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:gaa0c98b281c71db3fe71d9934d775fcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga627f9f91f1cab9898a5d8c8a6cb259eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga627f9f91f1cab9898a5d8c8a6cb259eb">av_frame_set_metadata</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, <a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *val)</td></tr>
<tr class="separator:ga627f9f91f1cab9898a5d8c8a6cb259eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67e6f896a782de75cc8fc11ce512412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gab67e6f896a782de75cc8fc11ce512412">av_frame_get_decode_error_flags</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:gab67e6f896a782de75cc8fc11ce512412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa50e609bbed3256839b77a5b8bf8d3fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaa50e609bbed3256839b77a5b8bf8d3fe">av_frame_set_decode_error_flags</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int val)</td></tr>
<tr class="separator:gaa50e609bbed3256839b77a5b8bf8d3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758b1631801dd0abe073aa94e69703d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga758b1631801dd0abe073aa94e69703d4">av_frame_get_pkt_size</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:ga758b1631801dd0abe073aa94e69703d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga456f04c3e9c0246e1632f1323f6f2f92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga456f04c3e9c0246e1632f1323f6f2f92">av_frame_set_pkt_size</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int val)</td></tr>
<tr class="separator:ga456f04c3e9c0246e1632f1323f6f2f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547036ebfd431346c512570d7316c241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga547036ebfd431346c512570d7316c241">av_frame_get_qp_table</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *f, int *stride, int *type)</td></tr>
<tr class="separator:ga547036ebfd431346c512570d7316c241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad08c37260c53f8587fe747dba285dd70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gad08c37260c53f8587fe747dba285dd70">av_frame_set_qp_table</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *f, <a class="el" href="structAVBufferRef.html">AVBufferRef</a> *buf, int stride, int type)</td></tr>
<tr class="separator:gad08c37260c53f8587fe747dba285dd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03cc0788d601ca46675256d56f6c018e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga03cc0788d601ca46675256d56f6c018e">av_frame_get_colorspace</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:ga03cc0788d601ca46675256d56f6c018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13d84467430d2ad75ce9e0091ca8f4c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga13d84467430d2ad75ce9e0091ca8f4c4">av_frame_set_colorspace</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a> val)</td></tr>
<tr class="separator:ga13d84467430d2ad75ce9e0091ca8f4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe34af632554dce15be46f3a89b574d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga7fe34af632554dce15be46f3a89b574d">av_frame_get_color_range</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="separator:ga7fe34af632554dce15be46f3a89b574d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24180c5de867fbdc50746cbe7023d624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga24180c5de867fbdc50746cbe7023d624">av_frame_set_color_range</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a> val)</td></tr>
<tr class="separator:ga24180c5de867fbdc50746cbe7023d624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e077dd848dd61ee4ac89ef4d3547cc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaf0e077dd848dd61ee4ac89ef4d3547cc">av_get_colorspace_name</a> (enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a> val)</td></tr>
<tr class="memdesc:gaf0e077dd848dd61ee4ac89ef4d3547cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a colorspace.  <a href="#gaf0e077dd848dd61ee4ac89ef4d3547cc">More...</a><br /></td></tr>
<tr class="separator:gaf0e077dd848dd61ee4ac89ef4d3547cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac700017c5270c79c1e1befdeeb008b2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f">av_frame_alloc</a> (void)</td></tr>
<tr class="memdesc:gac700017c5270c79c1e1befdeeb008b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> and set its fields to default values.  <a href="#gac700017c5270c79c1e1befdeeb008b2f">More...</a><br /></td></tr>
<tr class="separator:gac700017c5270c79c1e1befdeeb008b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979d73f3228814aee56aeca0636e37cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga979d73f3228814aee56aeca0636e37cc">av_frame_free</a> (<a class="el" href="structAVFrame.html">AVFrame</a> **<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="memdesc:ga979d73f3228814aee56aeca0636e37cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the frame and any dynamically allocated objects in it, e.g.  <a href="#ga979d73f3228814aee56aeca0636e37cc">More...</a><br /></td></tr>
<tr class="separator:ga979d73f3228814aee56aeca0636e37cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b0ecbc4eb3453eef3fbefa3bddeb7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga88b0ecbc4eb3453eef3fbefa3bddeb7c">av_frame_ref</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *dst, const <a class="el" href="structAVFrame.html">AVFrame</a> *src)</td></tr>
<tr class="memdesc:ga88b0ecbc4eb3453eef3fbefa3bddeb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a new reference to the data described by the source frame.  <a href="#ga88b0ecbc4eb3453eef3fbefa3bddeb7c">More...</a><br /></td></tr>
<tr class="separator:ga88b0ecbc4eb3453eef3fbefa3bddeb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d6d32f6482a3e9c19203db5877105b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga46d6d32f6482a3e9c19203db5877105b">av_frame_clone</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *src)</td></tr>
<tr class="memdesc:ga46d6d32f6482a3e9c19203db5877105b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new frame that references the same data as src.  <a href="#ga46d6d32f6482a3e9c19203db5877105b">More...</a><br /></td></tr>
<tr class="separator:ga46d6d32f6482a3e9c19203db5877105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2b687f9c1c5ed0089b01fd61227108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga0a2b687f9c1c5ed0089b01fd61227108">av_frame_unref</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="memdesc:ga0a2b687f9c1c5ed0089b01fd61227108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unreference all the buffers referenced by frame and reset the frame fields.  <a href="#ga0a2b687f9c1c5ed0089b01fd61227108">More...</a><br /></td></tr>
<tr class="separator:ga0a2b687f9c1c5ed0089b01fd61227108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709e62bc2917ffd84c5c0f4e1dfc48f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga709e62bc2917ffd84c5c0f4e1dfc48f7">av_frame_move_ref</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *dst, <a class="el" href="structAVFrame.html">AVFrame</a> *src)</td></tr>
<tr class="memdesc:ga709e62bc2917ffd84c5c0f4e1dfc48f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move everything contained in src to dst and reset src.  <a href="#ga709e62bc2917ffd84c5c0f4e1dfc48f7">More...</a><br /></td></tr>
<tr class="separator:ga709e62bc2917ffd84c5c0f4e1dfc48f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b1acbfa82c79bf7fd78d868572f0ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga6b1acbfa82c79bf7fd78d868572f0ceb">av_frame_get_buffer</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int align)</td></tr>
<tr class="memdesc:ga6b1acbfa82c79bf7fd78d868572f0ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate new buffer(s) for audio or video data.  <a href="#ga6b1acbfa82c79bf7fd78d868572f0ceb">More...</a><br /></td></tr>
<tr class="separator:ga6b1acbfa82c79bf7fd78d868572f0ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba755bada5c3c8883361ef43fb5fb7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga3ba755bada5c3c8883361ef43fb5fb7a">av_frame_is_writable</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="memdesc:ga3ba755bada5c3c8883361ef43fb5fb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the frame data is writable.  <a href="#ga3ba755bada5c3c8883361ef43fb5fb7a">More...</a><br /></td></tr>
<tr class="separator:ga3ba755bada5c3c8883361ef43fb5fb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd5417c06f5a6b419b0dbd8f0ff363fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gadd5417c06f5a6b419b0dbd8f0ff363fd">av_frame_make_writable</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>)</td></tr>
<tr class="memdesc:gadd5417c06f5a6b419b0dbd8f0ff363fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the frame data is writable, avoiding data copy if possible.  <a href="#gadd5417c06f5a6b419b0dbd8f0ff363fd">More...</a><br /></td></tr>
<tr class="separator:gadd5417c06f5a6b419b0dbd8f0ff363fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec4e92f6e1e75ffaf76e07586fb0c9ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaec4e92f6e1e75ffaf76e07586fb0c9ed">av_frame_copy</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *dst, const <a class="el" href="structAVFrame.html">AVFrame</a> *src)</td></tr>
<tr class="memdesc:gaec4e92f6e1e75ffaf76e07586fb0c9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the frame data from src to dst.  <a href="#gaec4e92f6e1e75ffaf76e07586fb0c9ed">More...</a><br /></td></tr>
<tr class="separator:gaec4e92f6e1e75ffaf76e07586fb0c9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b275b114ace0db95c5796bc71f3012"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gab9b275b114ace0db95c5796bc71f3012">av_frame_copy_props</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *dst, const <a class="el" href="structAVFrame.html">AVFrame</a> *src)</td></tr>
<tr class="memdesc:gab9b275b114ace0db95c5796bc71f3012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy only "metadata" fields from src to dst.  <a href="#gab9b275b114ace0db95c5796bc71f3012">More...</a><br /></td></tr>
<tr class="separator:gab9b275b114ace0db95c5796bc71f3012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb7f99dabe10fa5c7c078f4f5f173c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga7fb7f99dabe10fa5c7c078f4f5f173c5">av_frame_get_plane_buffer</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int plane)</td></tr>
<tr class="memdesc:ga7fb7f99dabe10fa5c7c078f4f5f173c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffer reference a given data plane is stored in.  <a href="#ga7fb7f99dabe10fa5c7c078f4f5f173c5">More...</a><br /></td></tr>
<tr class="separator:ga7fb7f99dabe10fa5c7c078f4f5f173c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4caf9361b00f9b2ab57c222dce3fec4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVFrameSideData.html">AVFrameSideData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gab4caf9361b00f9b2ab57c222dce3fec4">av_frame_new_side_data</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type, int size)</td></tr>
<tr class="memdesc:gab4caf9361b00f9b2ab57c222dce3fec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new side data to a frame.  <a href="#gab4caf9361b00f9b2ab57c222dce3fec4">More...</a><br /></td></tr>
<tr class="separator:gab4caf9361b00f9b2ab57c222dce3fec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc5b6e529eb7d82cc4aa285f790d66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVFrameSideData.html">AVFrameSideData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gabfc5b6e529eb7d82cc4aa285f790d66b">av_frame_new_side_data_from_buf</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type, <a class="el" href="structAVBufferRef.html">AVBufferRef</a> *buf)</td></tr>
<tr class="memdesc:gabfc5b6e529eb7d82cc4aa285f790d66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new side data to a frame from an existing <a class="el" href="structAVBufferRef.html" title="A reference to a data buffer. ">AVBufferRef</a>.  <a href="#gabfc5b6e529eb7d82cc4aa285f790d66b">More...</a><br /></td></tr>
<tr class="separator:gabfc5b6e529eb7d82cc4aa285f790d66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadec0efb470b1eead6a979333d9deca0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structAVFrameSideData.html">AVFrameSideData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gadec0efb470b1eead6a979333d9deca0c">av_frame_get_side_data</a> (const <a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type)</td></tr>
<tr class="separator:gadec0efb470b1eead6a979333d9deca0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132d6c01d0a21e5b48b96cd7c988de91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga132d6c01d0a21e5b48b96cd7c988de91">av_frame_remove_side_data</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type)</td></tr>
<tr class="memdesc:ga132d6c01d0a21e5b48b96cd7c988de91"><td class="mdescLeft">&#160;</td><td class="mdescRight">If side data of the supplied type exists in the frame, free it and remove it from the frame.  <a href="#ga132d6c01d0a21e5b48b96cd7c988de91">More...</a><br /></td></tr>
<tr class="separator:ga132d6c01d0a21e5b48b96cd7c988de91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea6d378ff15d984d4eb67b462b7d70b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#gaea6d378ff15d984d4eb67b462b7d70b5">av_frame_apply_cropping</a> (<a class="el" href="structAVFrame.html">AVFrame</a> *<a class="el" href="extract__mvs_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, int flags)</td></tr>
<tr class="memdesc:gaea6d378ff15d984d4eb67b462b7d70b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crop the given video <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> according to its crop_left/crop_top/crop_right/ crop_bottom fields.  <a href="#gaea6d378ff15d984d4eb67b462b7d70b5">More...</a><br /></td></tr>
<tr class="separator:gaea6d378ff15d984d4eb67b462b7d70b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cdb93858965e5afd6591792ffb72d99"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__frame.html#ga5cdb93858965e5afd6591792ffb72d99">av_frame_side_data_name</a> (enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a> type)</td></tr>
<tr class="separator:ga5cdb93858965e5afd6591792ffb72d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> is an abstraction for reference-counted raw multimedia data. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gae01fa7e427274293aacdf2adc17076bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae01fa7e427274293aacdf2adc17076bc">&#9670;&nbsp;</a></span>AVFrameSideDataType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca3de91a03b453c956b7274a2392d9a437"></a>AV_FRAME_DATA_PANSCAN&#160;</td><td class="fielddoc"><p>The data is the <a class="el" href="structAVPanScan.html" title="Pan Scan area. ">AVPanScan</a> struct defined in libavcodec. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca4848fd3952b4c2e1c1b85acb628c78a6"></a>AV_FRAME_DATA_A53_CC&#160;</td><td class="fielddoc"><p>ATSC A53 Part 4 Closed Captions. </p>
<p>A53 CC bitstream is stored as uint8_t in <a class="el" href="structAVFrameSideData.html#a76937ad48652a5a0cc4bff65fc6c886e">AVFrameSideData.data</a>. The number of bytes of CC data is <a class="el" href="structAVFrameSideData.html#aa8418cdc71a76dfab523445b17f10028">AVFrameSideData.size</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bcacec681d6146e8bd4c61b2e1cc88354a8"></a>AV_FRAME_DATA_STEREO3D&#160;</td><td class="fielddoc"><p>Stereoscopic 3d metadata. </p>
<p>The data is the <a class="el" href="structAVStereo3D.html" title="Stereo 3D type: this structure describes how two videos are packed within a single video surface...">AVStereo3D</a> struct defined in <a class="el" href="stereo3d_8h.html" title="Stereoscopic video. ">libavutil/stereo3d.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bcaa69ea5c11a5431bfff9e565714dafe41"></a>AV_FRAME_DATA_MATRIXENCODING&#160;</td><td class="fielddoc"><p>The data is the AVMatrixEncoding enum defined in <a class="el" href="channel__layout_8h.html" title="audio channel layout utility functions ">libavutil/channel_layout.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca71819257ea0bedb7e0740a0ce60e404a"></a>AV_FRAME_DATA_DOWNMIX_INFO&#160;</td><td class="fielddoc"><p>Metadata relevant to a downmix procedure. </p>
<p>The data is the <a class="el" href="structAVDownmixInfo.html" title="This structure describes optional metadata relevant to a downmix procedure. ">AVDownmixInfo</a> struct defined in <a class="el" href="downmix__info_8h.html" title="audio downmix medatata ">libavutil/downmix_info.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca66f46a9df9fcb8cf212e0693465794e1"></a>AV_FRAME_DATA_REPLAYGAIN&#160;</td><td class="fielddoc"><p>ReplayGain information in the form of the <a class="el" href="structAVReplayGain.html" title="ReplayGain information (see http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification). ">AVReplayGain</a> struct. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca3e01b882b6fa04724076067d6d9f8b69"></a>AV_FRAME_DATA_DISPLAYMATRIX&#160;</td><td class="fielddoc"><p>This side data contains a 3x3 transformation matrix describing an affine transformation that needs to be applied to the frame for correct presentation. </p>
<p>See <a class="el" href="display_8h.html" title="Display matrix. ">libavutil/display.h</a> for a detailed description of the data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca9aabf5c0b8abc7064bfcc59485e54aea"></a>AV_FRAME_DATA_AFD&#160;</td><td class="fielddoc"><p>Active Format Description data consisting of a single byte as specified in ETSI TS 101 154 using AVActiveFormatDescription enum. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bcaf50d0ed0a9a4517341c221be03a06c42"></a>AV_FRAME_DATA_MOTION_VECTORS&#160;</td><td class="fielddoc"><p>Motion vectors exported by some codecs (on demand through the export_mvs flag set in the libavcodec <a class="el" href="structAVCodecContext.html" title="main external API structure. ">AVCodecContext</a> flags2 option). </p>
<p>The data is the <a class="el" href="structAVMotionVector.html">AVMotionVector</a> struct defined in <a class="el" href="motion__vector_8h.html">libavutil/motion_vector.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca6b0b1ee4315f322922710f65d02a146b"></a>AV_FRAME_DATA_SKIP_SAMPLES&#160;</td><td class="fielddoc"><p>Recommmends skipping the specified number of samples. </p>
<p>This is exported only if the "skip_manual" <a class="el" href="structAVOption.html" title="AVOption. ">AVOption</a> is set in libavcodec. This has the same format as AV_PKT_DATA_SKIP_SAMPLES. </p><div class="fragment"><div class="line">u32le number of samples to skip from start of this packet</div><div class="line">u32le number of samples to skip from end of this packet</div><div class="line">u8    reason for start skip</div><div class="line">u8    reason for end   skip (0=padding silence, 1=convergence)</div></div><!-- fragment --> </td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca51023c847159dcc08776f9dcee5e0c90"></a>AV_FRAME_DATA_AUDIO_SERVICE_TYPE&#160;</td><td class="fielddoc"><p>This side data must be associated with an audio frame and corresponds to enum AVAudioServiceType defined in <a class="el" href="avcodec_8h.html" title="Libavcodec external API header. ">avcodec.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca6e305f92e325fbd219527452048f16cb"></a>AV_FRAME_DATA_MASTERING_DISPLAY_METADATA&#160;</td><td class="fielddoc"><p>Mastering display metadata associated with a video frame. </p>
<p>The payload is an <a class="el" href="structAVMasteringDisplayMetadata.html" title="Mastering display metadata capable of representing the color volume of the display used to master the...">AVMasteringDisplayMetadata</a> type and contains information about the mastering display color volume. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca03982b828a1069c895d16cda4b3e9fd4"></a>AV_FRAME_DATA_GOP_TIMECODE&#160;</td><td class="fielddoc"><p>The GOP timecode in 25 bit timecode format. </p>
<p>Data format is 64-bit integer. This is set on the first frame of a GOP that has a temporal reference of 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca12806c5fd4b37dca88312c61965f33e8"></a>AV_FRAME_DATA_SPHERICAL&#160;</td><td class="fielddoc"><p>The data represents the <a class="el" href="structAVSphericalMapping.html" title="This structure describes how to handle spherical videos, outlining information about projection...">AVSphericalMapping</a> structure defined in <a class="el" href="spherical_8h.html" title="Spherical video. ">libavutil/spherical.h</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca311f0afd2dded92ef68ae00f7711aa2d"></a>AV_FRAME_DATA_CONTENT_LIGHT_LEVEL&#160;</td><td class="fielddoc"><p>Content light level (based on CTA-861.3). </p>
<p>This payload contains data in the form of the <a class="el" href="structAVContentLightMetadata.html" title="Content light level needed by to transmit HDR over HDMI (CTA-861.3). ">AVContentLightMetadata</a> struct. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca8ef8866b8c04c54c630479bc163196ae"></a>AV_FRAME_DATA_ICC_PROFILE&#160;</td><td class="fielddoc"><p>The data contains an ICC profile as an opaque octet buffer following the format described by ISO 15076-1 with an optional name defined in the metadata key entry "name". </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca716dc238a2bea3693a52ab658c4e8ff7"></a>AV_FRAME_DATA_QP_TABLE_PROPERTIES&#160;</td><td class="fielddoc"><p>Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA. </p>
<p>The contents of this side data are undocumented and internal; use <a class="el" href="group__lavu__frame.html#gad08c37260c53f8587fe747dba285dd70">av_frame_set_qp_table()</a> and <a class="el" href="group__lavu__frame.html#ga547036ebfd431346c512570d7316c241">av_frame_get_qp_table()</a> to access this in a meaningful way instead. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca880fdfc059a05584749d695cc54e4717"></a>AV_FRAME_DATA_QP_TABLE_DATA&#160;</td><td class="fielddoc"><p>Raw QP table data. </p>
<p>Its format is described by AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use <a class="el" href="group__lavu__frame.html#gad08c37260c53f8587fe747dba285dd70">av_frame_set_qp_table()</a> and <a class="el" href="group__lavu__frame.html#ga547036ebfd431346c512570d7316c241">av_frame_get_qp_table()</a> to access this instead. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca9f4e4ed5a874d1089ec07c384b81bb70"></a>AV_FRAME_DATA_S12M_TIMECODE&#160;</td><td class="fielddoc"><p>Timecode which conforms to SMPTE ST 12-1. </p>
<p>The data is an array of 4 uint32_t where the first uint32_t describes how many (1-3) of the other timecodes are used. The timecode format is described in the <a class="el" href="timecode_8h.html#ae3045b65cc54f72e9d53d3c97a5f4da5" title="Convert frame number to SMPTE 12M binary representation. ">av_timecode_get_smpte_from_framenum()</a> function in libavutil/timecode.c. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bca624c3831cce31e4fcd3d2dc77c10b226"></a>AV_FRAME_DATA_DYNAMIC_HDR_PLUS&#160;</td><td class="fielddoc"><p>HDR dynamic metadata associated with a video frame. </p>
<p>The payload is an <a class="el" href="structAVDynamicHDRPlus.html" title="This struct represents dynamic metadata for color volume transform - application 4 of SMPTE 2094-40:2...">AVDynamicHDRPlus</a> type and contains information for color volume transform - application 4 of SMPTE 2094-40:2016 standard. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae01fa7e427274293aacdf2adc17076bcaf525ec92d2c5a78d44950bc3f29972aa"></a>AV_FRAME_DATA_REGIONS_OF_INTEREST&#160;</td><td class="fielddoc"><p>Regions Of Interest, the data is an array of <a class="el" href="structAVRegionOfInterest.html" title="Structure describing a single Region Of Interest. ">AVRegionOfInterest</a> type, the number of array element is implied by <a class="el" href="structAVFrameSideData.html#aa8418cdc71a76dfab523445b17f10028">AVFrameSideData.size</a> / <a class="el" href="structAVRegionOfInterest.html#a5c75595b7003be167ed674bf565654db" title="Must be set to the size of this data structure (that is, sizeof(AVRegionOfInterest)). ">AVRegionOfInterest.self_size</a>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="frame_8h_source.html#l00048">48</a> of file <a class="el" href="frame_8h_source.html">frame.h</a>.</p>

</div>
</div>
<a id="ga612627d8f03d52317992979dfa151d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga612627d8f03d52317992979dfa151d76">&#9670;&nbsp;</a></span>AVActiveFormatDescription</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lavu__frame.html#ga612627d8f03d52317992979dfa151d76">AVActiveFormatDescription</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76a0e9a49946d70eb6ca77cf937ed1a342c"></a>AV_AFD_SAME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76ab118e63239595dceb50deea7351dc1cb"></a>AV_AFD_4_3&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76ad8f8850e69a05765363a4a833adc97d8"></a>AV_AFD_16_9&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76a0da920de1ba63c73fabe1b9878477a13"></a>AV_AFD_14_9&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76a65edb00603a0d7fdb37cecac94b62cc5"></a>AV_AFD_4_3_SP_14_9&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76a488ce7ad4833c96497000dd03b8f0b55"></a>AV_AFD_16_9_SP_14_9&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga612627d8f03d52317992979dfa151d76aac53fd979d24b22c0673d1a0bc59e304"></a>AV_AFD_SP_4_3&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="frame_8h_source.html#l00184">184</a> of file <a class="el" href="frame_8h_source.html">frame.h</a>.</p>

</div>
</div>
<a id="ga61dadd085c1777f559549e05962b2c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61dadd085c1777f559549e05962b2c9e">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for frame cropping. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga61dadd085c1777f559549e05962b2c9ea8df6ec39909b8d97c0a6d2d8465d2e0f"></a>AV_FRAME_CROP_UNALIGNED&#160;</td><td class="fielddoc"><p>Apply the maximum possible cropping, even if it requires setting the <a class="el" href="structAVFrame.html#a1d0f65014a8d1bf78cec8cbed2304992" title="pointer to the picture/channel planes. ">AVFrame.data</a>[] entries to unaligned pointers. </p>
<p>Passing unaligned data to FFmpeg API is generally not allowed, and causes undefined behavior (such as crashes). You can pass unaligned data only to FFmpeg APIs that are explicitly documented to accept it. Use this flag only if you absolutely know what you are doing. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="frame_8h_source.html#l00932">932</a> of file <a class="el" href="frame_8h_source.html">frame.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga925e7d083e99a910b9c21268636cb712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga925e7d083e99a910b9c21268636cb712">&#9670;&nbsp;</a></span>av_frame_get_best_effort_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t av_frame_get_best_effort_timestamp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accessors for some <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> fields. </p>
<p>These used to be provided for ABI compatibility, and do not need to be used anymore. </p>

</div>
</div>
<a id="gad7708227eba08ff739576c251b174934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7708227eba08ff739576c251b174934">&#9670;&nbsp;</a></span>av_frame_set_best_effort_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_best_effort_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga50494987e9226a176284ae7f6134efc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50494987e9226a176284ae7f6134efc0">&#9670;&nbsp;</a></span>av_frame_get_pkt_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t av_frame_get_pkt_duration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga58b0960f75af92d98a41b5d640d31af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b0960f75af92d98a41b5d640d31af5">&#9670;&nbsp;</a></span>av_frame_set_pkt_duration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_pkt_duration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga65d2eb53158d00661efbdacdb1eef103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65d2eb53158d00661efbdacdb1eef103">&#9670;&nbsp;</a></span>av_frame_get_pkt_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t av_frame_get_pkt_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae2ebf63faa7bd8855738f8c6825d6da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ebf63faa7bd8855738f8c6825d6da6">&#9670;&nbsp;</a></span>av_frame_set_pkt_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_pkt_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8b71b6339d48f71999688af70190beee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b71b6339d48f71999688af70190beee">&#9670;&nbsp;</a></span>av_frame_get_channel_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int64_t av_frame_get_channel_layout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga87a6e7cdf7fe675be91b655dc4ae794e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87a6e7cdf7fe675be91b655dc4ae794e">&#9670;&nbsp;</a></span>av_frame_set_channel_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_channel_layout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga590db2f240eaa6ce998bfe3df5b9cb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga590db2f240eaa6ce998bfe3df5b9cb22">&#9670;&nbsp;</a></span>av_frame_get_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_get_channels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga53f781c6fc731399b2cdf63a97978d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53f781c6fc731399b2cdf63a97978d35">&#9670;&nbsp;</a></span>av_frame_set_channels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_channels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaadbff484111a2603b15cf982a4e710c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadbff484111a2603b15cf982a4e710c8">&#9670;&nbsp;</a></span>av_frame_get_sample_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_get_sample_rate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7b97de1236751c84523961595233837b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b97de1236751c84523961595233837b">&#9670;&nbsp;</a></span>av_frame_set_sample_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_sample_rate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa0c98b281c71db3fe71d9934d775fcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c98b281c71db3fe71d9934d775fcc0">&#9670;&nbsp;</a></span>av_frame_get_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a>* av_frame_get_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga627f9f91f1cab9898a5d8c8a6cb259eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga627f9f91f1cab9898a5d8c8a6cb259eb">&#9670;&nbsp;</a></span>av_frame_set_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_metadata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab67e6f896a782de75cc8fc11ce512412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67e6f896a782de75cc8fc11ce512412">&#9670;&nbsp;</a></span>av_frame_get_decode_error_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_get_decode_error_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa50e609bbed3256839b77a5b8bf8d3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa50e609bbed3256839b77a5b8bf8d3fe">&#9670;&nbsp;</a></span>av_frame_set_decode_error_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_decode_error_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga758b1631801dd0abe073aa94e69703d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga758b1631801dd0abe073aa94e69703d4">&#9670;&nbsp;</a></span>av_frame_get_pkt_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_get_pkt_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga456f04c3e9c0246e1632f1323f6f2f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga456f04c3e9c0246e1632f1323f6f2f92">&#9670;&nbsp;</a></span>av_frame_set_pkt_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_pkt_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga547036ebfd431346c512570d7316c241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga547036ebfd431346c512570d7316c241">&#9670;&nbsp;</a></span>av_frame_get_qp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int8_t* av_frame_get_qp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad08c37260c53f8587fe747dba285dd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad08c37260c53f8587fe747dba285dd70">&#9670;&nbsp;</a></span>av_frame_set_qp_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> int av_frame_set_qp_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga03cc0788d601ca46675256d56f6c018e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03cc0788d601ca46675256d56f6c018e">&#9670;&nbsp;</a></span>av_frame_get_colorspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a> av_frame_get_colorspace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga13d84467430d2ad75ce9e0091ca8f4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13d84467430d2ad75ce9e0091ca8f4c4">&#9670;&nbsp;</a></span>av_frame_set_colorspace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_colorspace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7fe34af632554dce15be46f3a89b574d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe34af632554dce15be46f3a89b574d">&#9670;&nbsp;</a></span>av_frame_get_color_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a> av_frame_get_color_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga24180c5de867fbdc50746cbe7023d624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24180c5de867fbdc50746cbe7023d624">&#9670;&nbsp;</a></span>av_frame_set_color_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> void av_frame_set_color_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="pixfmt_8h.html#a3da0bf691418bc22c4bcbe6583ad589a">AVColorRange</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf0e077dd848dd61ee4ac89ef4d3547cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0e077dd848dd61ee4ac89ef4d3547cc">&#9670;&nbsp;</a></span>av_get_colorspace_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_get_colorspace_name </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="pixfmt_8h.html#aff71a069509a1ad3ff54d53a1c894c85">AVColorSpace</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a colorspace. </p>
<dl class="section return"><dt>Returns</dt><dd>a static string identifying the colorspace; can be NULL. </dd></dl>

</div>
</div>
<a id="gac700017c5270c79c1e1befdeeb008b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac700017c5270c79c1e1befdeeb008b2f">&#9670;&nbsp;</a></span>av_frame_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVFrame.html">AVFrame</a>* av_frame_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> and set its fields to default values. </p>
<p>The resulting struct must be freed using <a class="el" href="group__lavu__frame.html#ga979d73f3228814aee56aeca0636e37cc" title="Free the frame and any dynamically allocated objects in it, e.g. ">av_frame_free()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> filled with default values or NULL on failure.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this only allocates the <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> itself, not the data buffers. Those must be allocated through other means, e.g. with <a class="el" href="group__lavu__frame.html#ga6b1acbfa82c79bf7fd78d868572f0ceb" title="Allocate new buffer(s) for audio or video data. ">av_frame_get_buffer()</a> or manually. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="decode_audio_8c-example.html#a29">decode_audio.c</a>, <a class="el" href="decode_video_8c-example.html#a29">decode_video.c</a>, <a class="el" href="demuxing_decoding_8c-example.html#a83">demuxing_decoding.c</a>, <a class="el" href="encode_audio_8c-example.html#a36">encode_audio.c</a>, <a class="el" href="encode_video_8c-example.html#a36">encode_video.c</a>, <a class="el" href="filter_audio_8c-example.html#a51">filter_audio.c</a>, <a class="el" href="filtering_audio_8c-example.html#a72">filtering_audio.c</a>, <a class="el" href="filtering_video_8c-example.html#a66">filtering_video.c</a>, <a class="el" href="hw_decode_8c-example.html#a16">hw_decode.c</a>, <a class="el" href="muxing_8c-example.html#a69">muxing.c</a>, <a class="el" href="transcode_aac_8c-example.html#a55">transcode_aac.c</a>, and <a class="el" href="transcoding_8c-example.html#a117">transcoding.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="muxing_8c_source.html#l00187">alloc_audio_frame()</a>, <a class="el" href="muxing_8c_source.html#l00373">alloc_picture()</a>, <a class="el" href="hw__decode_8c_source.html#l00077">decode_write()</a>, <a class="el" href="transcoding_8c_source.html#l00441">filter_encode_write_frame()</a>, <a class="el" href="transcode__aac_8c_source.html#l00263">init_input_frame()</a>, <a class="el" href="transcode__aac_8c_source.html#l00612">init_output_frame()</a>, and <a class="el" href="decode__audio_8c_source.html#l00076">main()</a>.</p>

</div>
</div>
<a id="ga979d73f3228814aee56aeca0636e37cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979d73f3228814aee56aeca0636e37cc">&#9670;&nbsp;</a></span>av_frame_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_frame_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> **&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the frame and any dynamically allocated objects in it, e.g. </p>
<p>extended_data. If the frame is reference counted, it will be unreferenced first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>frame to be freed. The pointer will be set to NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="decode_audio_8c-example.html#a37">decode_audio.c</a>, <a class="el" href="decode_video_8c-example.html#a36">decode_video.c</a>, <a class="el" href="demuxing_decoding_8c-example.html#a95">demuxing_decoding.c</a>, <a class="el" href="encode_audio_8c-example.html#a45">encode_audio.c</a>, <a class="el" href="encode_video_8c-example.html#a45">encode_video.c</a>, <a class="el" href="filter_audio_8c-example.html#a58">filter_audio.c</a>, <a class="el" href="filtering_audio_8c-example.html#a86">filtering_audio.c</a>, <a class="el" href="filtering_video_8c-example.html#a83">filtering_video.c</a>, <a class="el" href="hw_decode_8c-example.html#a20">hw_decode.c</a>, <a class="el" href="muxing_8c-example.html#a125">muxing.c</a>, <a class="el" href="transcode_aac_8c-example.html#a83">transcode_aac.c</a>, and <a class="el" href="transcoding_8c-example.html#a109">transcoding.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="muxing_8c_source.html#l00542">close_stream()</a>, <a class="el" href="hw__decode_8c_source.html#l00077">decode_write()</a>, <a class="el" href="transcoding_8c_source.html#l00405">encode_write_frame()</a>, <a class="el" href="transcoding_8c_source.html#l00441">filter_encode_write_frame()</a>, <a class="el" href="transcode__aac_8c_source.html#l00612">init_output_frame()</a>, <a class="el" href="transcode__aac_8c_source.html#l00728">load_encode_and_write()</a>, <a class="el" href="decode__audio_8c_source.html#l00076">main()</a>, and <a class="el" href="transcode__aac_8c_source.html#l00545">read_decode_convert_and_store()</a>.</p>

</div>
</div>
<a id="ga88b0ecbc4eb3453eef3fbefa3bddeb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b0ecbc4eb3453eef3fbefa3bddeb7c">&#9670;&nbsp;</a></span>av_frame_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a new reference to the data described by the source frame. </p>
<p>Copy frame properties from src to dst and create a new reference for each <a class="el" href="structAVBufferRef.html" title="A reference to a data buffer. ">AVBufferRef</a> from src.</p>
<p>If src is not reference counted, new buffers are allocated and the data is copied.</p>
<dl class="section warning"><dt>Warning</dt><dd>: dst MUST have been either unreferenced with av_frame_unref(dst), or newly allocated with <a class="el" href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f" title="Allocate an AVFrame and set its fields to default values. ">av_frame_alloc()</a> before calling this function, or undefined behavior will occur.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR on error </dd></dl>

</div>
</div>
<a id="ga46d6d32f6482a3e9c19203db5877105b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46d6d32f6482a3e9c19203db5877105b">&#9670;&nbsp;</a></span>av_frame_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVFrame.html">AVFrame</a>* av_frame_clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new frame that references the same data as src. </p>
<p>This is a shortcut for <a class="el" href="group__lavu__frame.html#gac700017c5270c79c1e1befdeeb008b2f" title="Allocate an AVFrame and set its fields to default values. ">av_frame_alloc()</a>+av_frame_ref().</p>
<dl class="section return"><dt>Returns</dt><dd>newly created <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> on success, NULL on error. </dd></dl>

</div>
</div>
<a id="ga0a2b687f9c1c5ed0089b01fd61227108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a2b687f9c1c5ed0089b01fd61227108">&#9670;&nbsp;</a></span>av_frame_unref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_frame_unref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unreference all the buffers referenced by frame and reset the frame fields. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="demuxing_decoding_8c-example.html#a49">demuxing_decoding.c</a>, <a class="el" href="filter_audio_8c-example.html#a54">filter_audio.c</a>, <a class="el" href="filtering_audio_8c-example.html#a81">filtering_audio.c</a>, and <a class="el" href="filtering_video_8c-example.html#a78">filtering_video.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="demuxing__decoding_8c_source.html#l00064">decode_packet()</a>, and <a class="el" href="filter__audio_8c_source.html#l00270">main()</a>.</p>

</div>
</div>
<a id="ga709e62bc2917ffd84c5c0f4e1dfc48f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga709e62bc2917ffd84c5c0f4e1dfc48f7">&#9670;&nbsp;</a></span>av_frame_move_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_frame_move_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move everything contained in src to dst and reset src. </p>
<dl class="section warning"><dt>Warning</dt><dd>: dst is not unreferenced, but directly overwritten without reading or deallocating its contents. Call av_frame_unref(dst) manually before calling this function to ensure that no memory is leaked. </dd></dl>

</div>
</div>
<a id="ga6b1acbfa82c79bf7fd78d868572f0ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b1acbfa82c79bf7fd78d868572f0ceb">&#9670;&nbsp;</a></span>av_frame_get_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_get_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate new buffer(s) for audio or video data. </p>
<p>The following fields must be set on frame before calling this function:</p><ul>
<li>format (pixel format for video, sample format for audio)</li>
<li>width and height for video</li>
<li>nb_samples and channel_layout for audio</li>
</ul>
<p>This function will fill <a class="el" href="structAVFrame.html#a1d0f65014a8d1bf78cec8cbed2304992" title="pointer to the picture/channel planes. ">AVFrame.data</a> and <a class="el" href="structAVFrame.html#a4a64d05cc676bfa8e18bf22d16c8a51f" title="AVBuffer references backing the data for this frame. ">AVFrame.buf</a> arrays and, if necessary, allocate and fill <a class="el" href="structAVFrame.html#afca04d808393822625e09b5ba91c6756" title="pointers to the data planes/channels. ">AVFrame.extended_data</a> and <a class="el" href="structAVFrame.html#a254a144d113ceedc003ec1547cc5bd54" title="For planar audio which requires more than AV_NUM_DATA_POINTERS AVBufferRef pointers, this array will hold all the references which cannot fit into AVFrame.buf. ">AVFrame.extended_buf</a>. For planar formats, one buffer will be allocated for each plane.</p>
<dl class="section warning"><dt>Warning</dt><dd>: if frame already has been allocated, calling this function will leak memory. In addition, undefined behavior can occur in certain cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>frame in which to store the new buffers. </td></tr>
    <tr><td class="paramname">align</td><td>Required buffer size alignment. If equal to 0, alignment will be chosen automatically for the current CPU. It is highly recommended to pass 0 here unless you know what you are doing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR on error. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="encode_audio_8c-example.html#a41">encode_audio.c</a>, <a class="el" href="encode_video_8c-example.html#a40">encode_video.c</a>, <a class="el" href="filter_audio_8c-example.html#a48">filter_audio.c</a>, <a class="el" href="muxing_8c-example.html#a74">muxing.c</a>, and <a class="el" href="transcode_aac_8c-example.html#a85">transcode_aac.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="muxing_8c_source.html#l00187">alloc_audio_frame()</a>, <a class="el" href="muxing_8c_source.html#l00373">alloc_picture()</a>, <a class="el" href="filter__audio_8c_source.html#l00242">get_input()</a>, <a class="el" href="transcode__aac_8c_source.html#l00612">init_output_frame()</a>, and <a class="el" href="encode__audio_8c_source.html#l00123">main()</a>.</p>

</div>
</div>
<a id="ga3ba755bada5c3c8883361ef43fb5fb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ba755bada5c3c8883361ef43fb5fb7a">&#9670;&nbsp;</a></span>av_frame_is_writable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_is_writable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the frame data is writable. </p>
<dl class="section return"><dt>Returns</dt><dd>A positive value if the frame data is writable (which is true if and only if each of the underlying buffers has only one reference, namely the one stored in this frame). Return 0 otherwise.</dd></dl>
<p>If 1 is returned the answer is valid until <a class="el" href="group__lavu__buffer.html#gaa40ce7d3ede946a89d03323bbd7268c1" title="Create a new reference to an AVBuffer. ">av_buffer_ref()</a> is called on any of the underlying AVBufferRefs (e.g. through <a class="el" href="group__lavu__frame.html#ga88b0ecbc4eb3453eef3fbefa3bddeb7c" title="Set up a new reference to the data described by the source frame. ">av_frame_ref()</a> or directly).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavu__frame.html#gadd5417c06f5a6b419b0dbd8f0ff363fd" title="Ensure that the frame data is writable, avoiding data copy if possible. ">av_frame_make_writable()</a>, <a class="el" href="group__lavu__buffer.html#ga060be34ace567ae378fd0a786e847053">av_buffer_is_writable()</a> </dd></dl>

</div>
</div>
<a id="gadd5417c06f5a6b419b0dbd8f0ff363fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd5417c06f5a6b419b0dbd8f0ff363fd">&#9670;&nbsp;</a></span>av_frame_make_writable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_make_writable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that the frame data is writable, avoiding data copy if possible. </p>
<p>Do nothing if the frame is writable, allocate new buffers and copy the data if it is not.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, a negative AVERROR on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavu__frame.html#ga3ba755bada5c3c8883361ef43fb5fb7a" title="Check if the frame data is writable. ">av_frame_is_writable()</a>, <a class="el" href="group__lavu__buffer.html#ga060be34ace567ae378fd0a786e847053">av_buffer_is_writable()</a>, <a class="el" href="group__lavu__buffer.html#ga9c2a1be1b7bb80eec8613fdb62a19074" title="Create a writable reference from a given buffer reference, avoiding data copy if possible. ">av_buffer_make_writable()</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="encode_audio_8c-example.html#a43">encode_audio.c</a>, <a class="el" href="encode_video_8c-example.html#a41">encode_video.c</a>, and <a class="el" href="muxing_8c-example.html#a103">muxing.c</a>.</dd>
</dl>
<p class="reference">Referenced by <a class="el" href="muxing_8c_source.html#l00461">get_video_frame()</a>, <a class="el" href="encode__audio_8c_source.html#l00123">main()</a>, and <a class="el" href="muxing_8c_source.html#l00309">write_audio_frame()</a>.</p>

</div>
</div>
<a id="gaec4e92f6e1e75ffaf76e07586fb0c9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec4e92f6e1e75ffaf76e07586fb0c9ed">&#9670;&nbsp;</a></span>av_frame_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the frame data from src to dst. </p>
<p>This function does not allocate anything, dst must be already initialized and allocated with the same parameters as src.</p>
<p>This function only copies the frame data (i.e. the contents of the data / extended data arrays), not any other properties.</p>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, a negative AVERROR on error. </dd></dl>

</div>
</div>
<a id="gab9b275b114ace0db95c5796bc71f3012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9b275b114ace0db95c5796bc71f3012">&#9670;&nbsp;</a></span>av_frame_copy_props()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_copy_props </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy only "metadata" fields from src to dst. </p>
<p>Metadata for the purpose of this function are those fields that do not affect the data layout in the buffers. E.g. pts, sample rate (for audio) or sample aspect ratio (for video), but not width/height or channel layout. Side data is also copied. </p>

</div>
</div>
<a id="ga7fb7f99dabe10fa5c7c078f4f5f173c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fb7f99dabe10fa5c7c078f4f5f173c5">&#9670;&nbsp;</a></span>av_frame_get_plane_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVBufferRef.html">AVBufferRef</a>* av_frame_get_plane_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>plane</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffer reference a given data plane is stored in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plane</td><td>index of the data plane of interest in frame-&gt;extended_data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the buffer reference that contains the plane or NULL if the input frame is not valid. </dd></dl>

</div>
</div>
<a id="gab4caf9361b00f9b2ab57c222dce3fec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4caf9361b00f9b2ab57c222dce3fec4">&#9670;&nbsp;</a></span>av_frame_new_side_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVFrameSideData.html">AVFrameSideData</a>* av_frame_new_side_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new side data to a frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>a frame to which the side data should be added </td></tr>
    <tr><td class="paramname">type</td><td>type of the added side data </td></tr>
    <tr><td class="paramname">size</td><td>size of the side data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly added side data on success, NULL on error </dd></dl>

</div>
</div>
<a id="gabfc5b6e529eb7d82cc4aa285f790d66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfc5b6e529eb7d82cc4aa285f790d66b">&#9670;&nbsp;</a></span>av_frame_new_side_data_from_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVFrameSideData.html">AVFrameSideData</a>* av_frame_new_side_data_from_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structAVBufferRef.html">AVBufferRef</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new side data to a frame from an existing <a class="el" href="structAVBufferRef.html" title="A reference to a data buffer. ">AVBufferRef</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>a frame to which the side data should be added </td></tr>
    <tr><td class="paramname">type</td><td>the type of the added side data </td></tr>
    <tr><td class="paramname">buf</td><td>an <a class="el" href="structAVBufferRef.html" title="A reference to a data buffer. ">AVBufferRef</a> to add as side data. The ownership of the reference is transferred to the frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly added side data on success, NULL on error. On failure the frame is unchanged and the <a class="el" href="structAVBufferRef.html" title="A reference to a data buffer. ">AVBufferRef</a> remains owned by the caller. </dd></dl>

</div>
</div>
<a id="gadec0efb470b1eead6a979333d9deca0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadec0efb470b1eead6a979333d9deca0c">&#9670;&nbsp;</a></span>av_frame_get_side_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structAVFrameSideData.html">AVFrameSideData</a>* av_frame_get_side_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to the side data of a given type on success, NULL if there is no side data with such type in this frame. </dd></dl>

<p class="reference">Referenced by <a class="el" href="extract__mvs_8c_source.html#l00036">decode_packet()</a>.</p>

</div>
</div>
<a id="ga132d6c01d0a21e5b48b96cd7c988de91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga132d6c01d0a21e5b48b96cd7c988de91">&#9670;&nbsp;</a></span>av_frame_remove_side_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_frame_remove_side_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If side data of the supplied type exists in the frame, free it and remove it from the frame. </p>

</div>
</div>
<a id="gaea6d378ff15d984d4eb67b462b7d70b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea6d378ff15d984d4eb67b462b7d70b5">&#9670;&nbsp;</a></span>av_frame_apply_cropping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_frame_apply_cropping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAVFrame.html">AVFrame</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crop the given video <a class="el" href="structAVFrame.html" title="This structure describes decoded (raw) audio or video data. ">AVFrame</a> according to its crop_left/crop_top/crop_right/ crop_bottom fields. </p>
<p>If cropping is successful, the function will adjust the data pointers and the width/height fields, and set the crop fields to 0.</p>
<p>In all cases, the cropping boundaries will be rounded to the inherent alignment of the pixel format. In some cases, such as for opaque hwaccel formats, the left/top cropping is ignored. The crop fields are set to 0 even if the cropping was rounded or ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>the frame which should be cropped </td></tr>
    <tr><td class="paramname">flags</td><td>Some combination of AV_FRAME_CROP_* flags, or 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, a negative AVERROR on error. If the cropping fields were invalid, <a class="el" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR(ERANGE)</a> is returned, and nothing is changed. </dd></dl>

</div>
</div>
<a id="ga5cdb93858965e5afd6591792ffb72d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cdb93858965e5afd6591792ffb72d99">&#9670;&nbsp;</a></span>av_frame_side_data_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_frame_side_data_name </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="group__lavu__frame.html#gae01fa7e427274293aacdf2adc17076bc">AVFrameSideDataType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a string identifying the side data type </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
