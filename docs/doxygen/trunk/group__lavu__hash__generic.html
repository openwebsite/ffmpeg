<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpeg: Generic Hashing API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpeg
   &#160;<span id="projectnumber">4.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Generic Hashing API<div class="ingroups"><a class="el" href="group__lavu.html">libavutil</a> &raquo; <a class="el" href="group__lavu__crypto.html">Crypto and Hashing</a> &raquo; <a class="el" href="group__lavu__hash.html">Hash Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstraction layer for all hash functions supported by libavutil.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hash_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hash_8h.html">hash.h</a></td></tr>
<tr class="memdesc:hash_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic hashing API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaff5173f8837eb3afbd20b52528833d72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gaff5173f8837eb3afbd20b52528833d72">AV_HASH_MAX_SIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:gaff5173f8837eb3afbd20b52528833d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value that <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a> will currently return.  <a href="#gaff5173f8837eb3afbd20b52528833d72">More...</a><br /></td></tr>
<tr class="separator:gaff5173f8837eb3afbd20b52528833d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad1e018687f3a0e9baf3fb6d3af0dd10b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gad1e018687f3a0e9baf3fb6d3af0dd10b">av_hash_alloc</a> (struct AVHashContext **ctx, const char *name)</td></tr>
<tr class="memdesc:gad1e018687f3a0e9baf3fb6d3af0dd10b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a hash context for the algorithm specified by name.  <a href="#gad1e018687f3a0e9baf3fb6d3af0dd10b">More...</a><br /></td></tr>
<tr class="separator:gad1e018687f3a0e9baf3fb6d3af0dd10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62537bbcf4cae67bbb33f3fa4f4329bf"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga62537bbcf4cae67bbb33f3fa4f4329bf">av_hash_names</a> (int i)</td></tr>
<tr class="memdesc:ga62537bbcf4cae67bbb33f3fa4f4329bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the names of available hash algorithms.  <a href="#ga62537bbcf4cae67bbb33f3fa4f4329bf">More...</a><br /></td></tr>
<tr class="separator:ga62537bbcf4cae67bbb33f3fa4f4329bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5952d21d5503ac307fbaa5d05a3d93ca"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga5952d21d5503ac307fbaa5d05a3d93ca">av_hash_get_name</a> (const struct AVHashContext *ctx)</td></tr>
<tr class="memdesc:ga5952d21d5503ac307fbaa5d05a3d93ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the algorithm corresponding to the given hash context.  <a href="#ga5952d21d5503ac307fbaa5d05a3d93ca">More...</a><br /></td></tr>
<tr class="separator:ga5952d21d5503ac307fbaa5d05a3d93ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf8f94e3ebf73f838d017f83352d880"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size</a> (const struct AVHashContext *ctx)</td></tr>
<tr class="memdesc:ga8bf8f94e3ebf73f838d017f83352d880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the resulting hash value in bytes.  <a href="#ga8bf8f94e3ebf73f838d017f83352d880">More...</a><br /></td></tr>
<tr class="separator:ga8bf8f94e3ebf73f838d017f83352d880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ef872a731eb5c2637ddcd0f0976bca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca">av_hash_init</a> (struct AVHashContext *ctx)</td></tr>
<tr class="memdesc:ga84ef872a731eb5c2637ddcd0f0976bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reset a hash context.  <a href="#ga84ef872a731eb5c2637ddcd0f0976bca">More...</a><br /></td></tr>
<tr class="separator:ga84ef872a731eb5c2637ddcd0f0976bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a467ff60cb5080b56e818e7b8adb4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gac6a467ff60cb5080b56e818e7b8adb4a">av_hash_update</a> (struct AVHashContext *ctx, const uint8_t *src, int len)</td></tr>
<tr class="memdesc:gac6a467ff60cb5080b56e818e7b8adb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a hash context with additional data.  <a href="#gac6a467ff60cb5080b56e818e7b8adb4a">More...</a><br /></td></tr>
<tr class="separator:gac6a467ff60cb5080b56e818e7b8adb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff9a69f576f8f94e33a0b43a08baa70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#gaeff9a69f576f8f94e33a0b43a08baa70">av_hash_final</a> (struct AVHashContext *ctx, uint8_t *dst)</td></tr>
<tr class="memdesc:gaeff9a69f576f8f94e33a0b43a08baa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a hash context and compute the actual hash value.  <a href="#gaeff9a69f576f8f94e33a0b43a08baa70">More...</a><br /></td></tr>
<tr class="separator:gaeff9a69f576f8f94e33a0b43a08baa70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e1a59bf9c2076eda5884e89249af12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga65e1a59bf9c2076eda5884e89249af12">av_hash_final_bin</a> (struct AVHashContext *ctx, uint8_t *dst, int size)</td></tr>
<tr class="memdesc:ga65e1a59bf9c2076eda5884e89249af12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a hash context and store the actual hash value in a buffer.  <a href="#ga65e1a59bf9c2076eda5884e89249af12">More...</a><br /></td></tr>
<tr class="separator:ga65e1a59bf9c2076eda5884e89249af12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8316ebcbe11caebc88b4c4afc0eef16c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga8316ebcbe11caebc88b4c4afc0eef16c">av_hash_final_hex</a> (struct AVHashContext *ctx, uint8_t *dst, int size)</td></tr>
<tr class="memdesc:ga8316ebcbe11caebc88b4c4afc0eef16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a hash context and store the hexadecimal representation of the actual hash value as a string.  <a href="#ga8316ebcbe11caebc88b4c4afc0eef16c">More...</a><br /></td></tr>
<tr class="separator:ga8316ebcbe11caebc88b4c4afc0eef16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2300a29e15fd439bcac2f9bc35b730ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga2300a29e15fd439bcac2f9bc35b730ca">av_hash_final_b64</a> (struct AVHashContext *ctx, uint8_t *dst, int size)</td></tr>
<tr class="memdesc:ga2300a29e15fd439bcac2f9bc35b730ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a hash context and store the Base64 representation of the actual hash value as a string.  <a href="#ga2300a29e15fd439bcac2f9bc35b730ca">More...</a><br /></td></tr>
<tr class="separator:ga2300a29e15fd439bcac2f9bc35b730ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8bac529966e9af25f3608d3a1515ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__hash__generic.html#ga1e8bac529966e9af25f3608d3a1515ab">av_hash_freep</a> (struct AVHashContext **ctx)</td></tr>
<tr class="memdesc:ga1e8bac529966e9af25f3608d3a1515ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free hash context and set hash context pointer to <code>NULL</code>.  <a href="#ga1e8bac529966e9af25f3608d3a1515ab">More...</a><br /></td></tr>
<tr class="separator:ga1e8bac529966e9af25f3608d3a1515ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>An abstraction layer for all hash functions supported by libavutil. </p>
<p>If your application needs to support a wide range of different hash functions, then the Generic Hashing API is for you. It provides a generic, reusable API for <a class="el" href="group__lavu__hash.html">all hash functions</a> implemented in libavutil. If you just need to use one particular hash function, use the <a class="el" href="group__lavu__hash.html">individual hash</a> directly.</p>
<h1><a class="anchor" id="Sample"></a>
Code</h1>
<p>A basic template for using the Generic Hashing API follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>AVHashContext *ctx = NULL;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *hash_name = NULL;</div><div class="line">uint8_t *output_buf = NULL;</div><div class="line"></div><div class="line"><span class="comment">// Select from a string returned by av_hash_names()</span></div><div class="line">hash_name = ...;</div><div class="line"></div><div class="line"><span class="comment">// Allocate a hash context</span></div><div class="line">ret = <a class="code" href="group__lavu__hash__generic.html#gad1e018687f3a0e9baf3fb6d3af0dd10b">av_hash_alloc</a>(&amp;ctx, hash_name);</div><div class="line"><span class="keywordflow">if</span> (ret &lt; 0)</div><div class="line">    <span class="keywordflow">return</span> ret;</div><div class="line"></div><div class="line"><span class="comment">// Initialize the hash context</span></div><div class="line"><a class="code" href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca">av_hash_init</a>(ctx);</div><div class="line"></div><div class="line"><span class="comment">// Update the hash context with data</span></div><div class="line"><span class="keywordflow">while</span> (data_left) {</div><div class="line">    <a class="code" href="group__lavu__hash__generic.html#gac6a467ff60cb5080b56e818e7b8adb4a">av_hash_update</a>(ctx, data, size);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Now we have no more data, so it is time to finalize the hash and get the</span></div><div class="line"><span class="comment">// output. But we need to first allocate an output buffer. Note that you can</span></div><div class="line"><span class="comment">// use any memory allocation function, including malloc(), not just</span></div><div class="line"><span class="comment">// av_malloc().</span></div><div class="line">output_buf = <a class="code" href="group__lavu__mem__funcs.html#ga7c4f0fe9fe716121ce05f7170810ce8e">av_malloc</a>(<a class="code" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880">av_hash_get_size</a>(ctx));</div><div class="line"><span class="keywordflow">if</span> (!output_buf)</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__lavu__error.html#gae4bb6f165973d09584e0ec0f335f69ca">AVERROR</a>(ENOMEM);</div><div class="line"></div><div class="line"><span class="comment">// Finalize the hash context.</span></div><div class="line"><span class="comment">// You can use any of the av_hash_final*() functions provided, for other</span></div><div class="line"><span class="comment">// output formats. If you do so, be sure to adjust the memory allocation</span></div><div class="line"><span class="comment">// above. See the function documentation below for the exact amount of extra</span></div><div class="line"><span class="comment">// memory needed.</span></div><div class="line"><a class="code" href="group__lavu__hash__generic.html#gaeff9a69f576f8f94e33a0b43a08baa70">av_hash_final</a>(ctx, output_buffer);</div><div class="line"></div><div class="line"><span class="comment">// Free the context</span></div><div class="line"><a class="code" href="group__lavu__hash__generic.html#ga1e8bac529966e9af25f3608d3a1515ab">av_hash_freep</a>(&amp;ctx);</div></div><!-- fragment --><h1><a class="anchor" id="Hash"></a>
Function-Specific Information</h1>
<p>If the CRC32 hash is selected, the <a class="el" href="group__lavu__crc32.html#ggab7717a9f1179a5ac8516982f9f2997d2a2c95e44f51d497669d7c49d58018dea1">AV_CRC_32_IEEE</a> polynomial will be used.</p>
<p>If the Murmur3 hash is selected, the default seed will be used. See <a class="el" href="group__lavu__murmur3.html#lavu_murmur3_seedinfo">Murmur3</a> for more information. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaff5173f8837eb3afbd20b52528833d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5173f8837eb3afbd20b52528833d72">&#9670;&nbsp;</a></span>AV_HASH_MAX_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AV_HASH_MAX_SIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum value that <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a> will currently return. </p>
<p>You can use this if you absolutely want or need to use static allocation for the output buffer and are fine with not supporting hashes newly added to libavutil without recompilation.</p>
<dl class="section warning"><dt>Warning</dt><dd>Adding new hashes with larger sizes, and increasing the macro while doing so, will not be considered an ABI change. To prevent your code from overflowing a buffer, either dynamically allocate the output buffer with <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a>, or limit your use of the Hashing API to hashes that are already in FFmpeg during the time of compilation. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a2">ffhash.c</a>.</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="hash_8h_source.html#l00157">157</a> of file <a class="el" href="hash_8h_source.html">hash.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad1e018687f3a0e9baf3fb6d3af0dd10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e018687f3a0e9baf3fb6d3af0dd10b">&#9670;&nbsp;</a></span>av_hash_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_hash_alloc </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext **&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a hash context for the algorithm specified by name. </p>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 for success, a negative error code for failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The context is not initialized after a call to this function; you must call <a class="el" href="group__lavu__hash__generic.html#ga84ef872a731eb5c2637ddcd0f0976bca" title="Initialize or reset a hash context. ">av_hash_init()</a> to do so. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a10">ffhash.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga62537bbcf4cae67bbb33f3fa4f4329bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62537bbcf4cae67bbb33f3fa4f4329bf">&#9670;&nbsp;</a></span>av_hash_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_hash_names </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the names of available hash algorithms. </p>
<p>This function can be used to enumerate the algorithms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of the hash algorithm, starting from 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a static string or <code>NULL</code> if <code>i</code> is out of range </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a1">ffhash.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga5952d21d5503ac307fbaa5d05a3d93ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5952d21d5503ac307fbaa5d05a3d93ca">&#9670;&nbsp;</a></span>av_hash_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* av_hash_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the algorithm corresponding to the given hash context. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a3">ffhash.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga8bf8f94e3ebf73f838d017f83352d880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf8f94e3ebf73f838d017f83352d880">&#9670;&nbsp;</a></span>av_hash_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int av_hash_get_size </td>
          <td>(</td>
          <td class="paramtype">const struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the resulting hash value in bytes. </p>
<p>The maximum value this function will currently return is available as macro <a class="el" href="group__lavu__hash__generic.html#gaff5173f8837eb3afbd20b52528833d72" title="Maximum value that av_hash_get_size() will currently return. ">AV_HASH_MAX_SIZE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the hash value in bytes </dd></dl>

</div>
</div>
<a id="ga84ef872a731eb5c2637ddcd0f0976bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84ef872a731eb5c2637ddcd0f0976bca">&#9670;&nbsp;</a></span>av_hash_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_init </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize or reset a hash context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a6">ffhash.c</a>.</dd>
</dl>
</div>
</div>
<a id="gac6a467ff60cb5080b56e818e7b8adb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a467ff60cb5080b56e818e7b8adb4a">&#9670;&nbsp;</a></span>av_hash_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_update </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a hash context with additional data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Data to be added to the hash context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Size of the additional data </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a7">ffhash.c</a>.</dd>
</dl>
</div>
</div>
<a id="gaeff9a69f576f8f94e33a0b43a08baa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeff9a69f576f8f94e33a0b43a08baa70">&#9670;&nbsp;</a></span>av_hash_final()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_final </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a hash context and compute the actual hash value. </p>
<p>The minimum size of <code>dst</code> buffer is given by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a> or <a class="el" href="group__lavu__hash__generic.html#gaff5173f8837eb3afbd20b52528833d72" title="Maximum value that av_hash_get_size() will currently return. ">AV_HASH_MAX_SIZE</a>. The use of the latter macro is discouraged.</p>
<p>It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the final hash value will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__lavu__hash__generic.html#ga65e1a59bf9c2076eda5884e89249af12" title="Finalize a hash context and store the actual hash value in a buffer. ">av_hash_final_bin()</a> provides an alternative API </dd></dl>

</div>
</div>
<a id="ga65e1a59bf9c2076eda5884e89249af12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65e1a59bf9c2076eda5884e89249af12">&#9670;&nbsp;</a></span>av_hash_final_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_final_bin </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a hash context and store the actual hash value in a buffer. </p>
<p>It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<p>If <code>size</code> is smaller than the hash size (given by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a>), the hash is truncated; if size is larger, the buffer is padded with 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the final hash value will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of bytes to write to <code>dst</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8316ebcbe11caebc88b4c4afc0eef16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8316ebcbe11caebc88b4c4afc0eef16c">&#9670;&nbsp;</a></span>av_hash_final_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_final_hex </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a hash context and store the hexadecimal representation of the actual hash value as a string. </p>
<p>It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<p>The string is always 0-terminated.</p>
<p>If <code>size</code> is smaller than <code>2 * hash_size + 1</code>, where <code>hash_size</code> is the value returned by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a>, the string will be truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the string will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes to write to <code>dst</code> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a5">ffhash.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga2300a29e15fd439bcac2f9bc35b730ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2300a29e15fd439bcac2f9bc35b730ca">&#9670;&nbsp;</a></span>av_hash_final_b64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_final_b64 </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a hash context and store the Base64 representation of the actual hash value as a string. </p>
<p>It is not safe to update or finalize a hash context again, if it has already been finalized.</p>
<p>The string is always 0-terminated.</p>
<p>If <code>size</code> is smaller than <a class="el" href="group__lavu__base64.html#gaa79f39ca3f737b662ae6711d2cbecd20" title="Calculate the output size needed to base64-encode x bytes to a null-terminated string. ">AV_BASE64_SIZE(hash_size)</a>, where <code>hash_size</code> is the value returned by <a class="el" href="group__lavu__hash__generic.html#ga8bf8f94e3ebf73f838d017f83352d880" title="Get the size of the resulting hash value in bytes. ">av_hash_get_size()</a>, the string will be truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Hash context </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>Where the final hash value will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Maximum number of bytes to write to <code>dst</code> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a4">ffhash.c</a>.</dd>
</dl>
</div>
</div>
<a id="ga1e8bac529966e9af25f3608d3a1515ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e8bac529966e9af25f3608d3a1515ab">&#9670;&nbsp;</a></span>av_hash_freep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_hash_freep </td>
          <td>(</td>
          <td class="paramtype">struct AVHashContext **&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free hash context and set hash context pointer to <code>NULL</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ctx</td><td>Pointer to hash context </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ffhash_8c-example.html#a12">ffhash.c</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
