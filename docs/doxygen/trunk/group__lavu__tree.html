<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpeg: AVTree</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpeg
   &#160;<span id="projectnumber">4.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">AVTree<div class="ingroups"><a class="el" href="group__lavu.html">libavutil</a> &raquo; <a class="el" href="group__lavu__data.html">Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Low-complexity tree container.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa22713575bd8846e61128660b6b2c952"><td class="memItemLeft" align="right" valign="top">struct AVTreeNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__tree.html#gaa22713575bd8846e61128660b6b2c952">av_tree_node_alloc</a> (void)</td></tr>
<tr class="memdesc:gaa22713575bd8846e61128660b6b2c952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an AVTreeNode.  <a href="#gaa22713575bd8846e61128660b6b2c952">More...</a><br /></td></tr>
<tr class="separator:gaa22713575bd8846e61128660b6b2c952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf577181dd95c6c922c1e530c4f0ef66b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__tree.html#gaf577181dd95c6c922c1e530c4f0ef66b">av_tree_find</a> (const struct AVTreeNode *root, void *key, int(*cmp)(const void *key, const void *b), void *next[2])</td></tr>
<tr class="memdesc:gaf577181dd95c6c922c1e530c4f0ef66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an element.  <a href="#gaf577181dd95c6c922c1e530c4f0ef66b">More...</a><br /></td></tr>
<tr class="separator:gaf577181dd95c6c922c1e530c4f0ef66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40aae331288a02ddcbb963b0cad95f66"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__tree.html#ga40aae331288a02ddcbb963b0cad95f66">av_tree_insert</a> (struct AVTreeNode **rootp, void *key, int(*cmp)(const void *key, const void *b), struct AVTreeNode **next)</td></tr>
<tr class="memdesc:ga40aae331288a02ddcbb963b0cad95f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or remove an element.  <a href="#ga40aae331288a02ddcbb963b0cad95f66">More...</a><br /></td></tr>
<tr class="separator:ga40aae331288a02ddcbb963b0cad95f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2f16a7b3895fd776696cd9eccd6c26a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__tree.html#gae2f16a7b3895fd776696cd9eccd6c26a">av_tree_destroy</a> (struct AVTreeNode *t)</td></tr>
<tr class="separator:gae2f16a7b3895fd776696cd9eccd6c26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7cce17e3ab55eb07c6ad8739ff58d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__tree.html#ga1c7cce17e3ab55eb07c6ad8739ff58d2">av_tree_enumerate</a> (struct AVTreeNode *t, void *opaque, int(*cmp)(void *opaque, void *elem), int(*enu)(void *opaque, void *elem))</td></tr>
<tr class="memdesc:ga1c7cce17e3ab55eb07c6ad8739ff58d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply enu(opaque, &amp;elem) to all the elements in the tree in a given range.  <a href="#ga1c7cce17e3ab55eb07c6ad8739ff58d2">More...</a><br /></td></tr>
<tr class="separator:ga1c7cce17e3ab55eb07c6ad8739ff58d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gabad004dcf19a9d481793c03cabda5984"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lavu__tree.html#gabad004dcf19a9d481793c03cabda5984">av_tree_node_size</a></td></tr>
<tr class="separator:gabad004dcf19a9d481793c03cabda5984"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low-complexity tree container. </p>
<p>Insertion, removal, finding equal, largest which is smaller than and smallest which is larger than, all have O(log n) worst-case complexity. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa22713575bd8846e61128660b6b2c952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa22713575bd8846e61128660b6b2c952">&#9670;&nbsp;</a></span>av_tree_node_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct AVTreeNode* av_tree_node_alloc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an AVTreeNode. </p>

</div>
</div>
<a id="gaf577181dd95c6c922c1e530c4f0ef66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf577181dd95c6c922c1e530c4f0ef66b">&#9670;&nbsp;</a></span>av_tree_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* av_tree_find </td>
          <td>(</td>
          <td class="paramtype">const struct AVTreeNode *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *key, const void *b)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>next</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>a pointer to the root node of the tree </td></tr>
    <tr><td class="paramname">next</td><td>If next is not NULL, then next[0] will contain the previous element and next[1] the next element. If either does not exist, then the corresponding entry in next is unchanged. </td></tr>
    <tr><td class="paramname">cmp</td><td>compare function used to compare elements in the tree, API identical to that of Standard C's qsort It is guaranteed that the first and only the first argument to cmp() will be the key parameter to <a class="el" href="group__lavu__tree.html#gaf577181dd95c6c922c1e530c4f0ef66b" title="Find an element. ">av_tree_find()</a>, thus it could if the user wants, be a different type (like an opaque context). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An element with cmp(key, elem) == 0 or NULL if no such element exists in the tree. </dd></dl>

</div>
</div>
<a id="ga40aae331288a02ddcbb963b0cad95f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40aae331288a02ddcbb963b0cad95f66">&#9670;&nbsp;</a></span>av_tree_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* av_tree_insert </td>
          <td>(</td>
          <td class="paramtype">struct AVTreeNode **&#160;</td>
          <td class="paramname"><em>rootp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *key, const void *b)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct AVTreeNode **&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert or remove an element. </p>
<p>If *next is NULL, then the supplied element will be removed if it exists. If *next is non-NULL, then the supplied element will be inserted, unless it already exists in the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootp</td><td>A pointer to a pointer to the root node of the tree; note that the root node can change during insertions, this is required to keep the tree balanced. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the element key to insert in the tree </td></tr>
    <tr><td class="paramname">next</td><td>Used to allocate and free AVTreeNodes. For insertion the user must set it to an allocated and zeroed object of at least av_tree_node_size bytes size. <a class="el" href="group__lavu__tree.html#ga40aae331288a02ddcbb963b0cad95f66" title="Insert or remove an element. ">av_tree_insert()</a> will set it to NULL if it has been consumed. For deleting elements *next is set to NULL by the user and <a class="el" href="group__lavu__tree.html#ga40aae331288a02ddcbb963b0cad95f66" title="Insert or remove an element. ">av_tree_insert()</a> will set it to the AVTreeNode which was used for the removed element. This allows the use of flat arrays, which have lower overhead compared to many malloced elements. You might want to define a function like: <div class="fragment"><div class="line"><span class="keywordtype">void</span> *tree_insert(<span class="keyword">struct</span> AVTreeNode **rootp, <span class="keywordtype">void</span> *key,</div><div class="line">                  <span class="keywordtype">int</span> (*cmp)(<span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *b),</div><div class="line">                  AVTreeNode **next)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (!*next)</div><div class="line">        *next = <a class="code" href="group__lavu__mem__funcs.html#ga6a42cc41278e2f5a5b658d2202d1650d">av_mallocz</a>(<a class="code" href="group__lavu__tree.html#gabad004dcf19a9d481793c03cabda5984">av_tree_node_size</a>);</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__lavu__tree.html#ga40aae331288a02ddcbb963b0cad95f66">av_tree_insert</a>(rootp, key, cmp, next);</div><div class="line">}</div><div class="line"><span class="keywordtype">void</span> *tree_remove(<span class="keyword">struct</span> AVTreeNode **rootp, <span class="keywordtype">void</span> *key,</div><div class="line">                  <span class="keywordtype">int</span> (*cmp)(<span class="keywordtype">void</span> *key, <span class="keyword">const</span> <span class="keywordtype">void</span> *b, AVTreeNode **next))</div><div class="line">{</div><div class="line">    <a class="code" href="group__lavu__mem__funcs.html#ga0cc84043ea2167ad005c86e11d0bcdba">av_freep</a>(next);</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__lavu__tree.html#ga40aae331288a02ddcbb963b0cad95f66">av_tree_insert</a>(rootp, key, cmp, next);</div><div class="line">}</div></div><!-- fragment --> </td></tr>
    <tr><td class="paramname">cmp</td><td>compare function used to compare elements in the tree, API identical to that of Standard C's qsort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If no insertion happened, the found element; if an insertion or removal happened, then either key or NULL will be returned. Which one it is depends on the tree state and the implementation. You should make no assumptions that it's one or the other in the code. </dd></dl>

</div>
</div>
<a id="gae2f16a7b3895fd776696cd9eccd6c26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2f16a7b3895fd776696cd9eccd6c26a">&#9670;&nbsp;</a></span>av_tree_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_tree_destroy </td>
          <td>(</td>
          <td class="paramtype">struct AVTreeNode *&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1c7cce17e3ab55eb07c6ad8739ff58d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c7cce17e3ab55eb07c6ad8739ff58d2">&#9670;&nbsp;</a></span>av_tree_enumerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void av_tree_enumerate </td>
          <td>(</td>
          <td class="paramtype">struct AVTreeNode *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *opaque, void *elem)&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(void *opaque, void *elem)&#160;</td>
          <td class="paramname"><em>enu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply enu(opaque, &amp;elem) to all the elements in the tree in a given range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>a comparison function that returns &lt; 0 for an element below the range, &gt; 0 for an element above the range and == 0 for an element inside the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The cmp function should use the same ordering used to construct the tree. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gabad004dcf19a9d481793c03cabda5984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabad004dcf19a9d481793c03cabda5984">&#9670;&nbsp;</a></span>av_tree_node_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int av_tree_node_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
